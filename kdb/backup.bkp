use core::result::Result as StdResult;
use kdbplus::ipc::K;
use kdbplus::ipc::*;
use kdbplus::*;
use polars_core::prelude::*;
use py_types::{py_error, DBError, PySQLXError};
use pyo3::prelude::*;
use pyo3_polars::PyDataFrame;
use core::result::Result;
use super::helpers::*;

#[pyclass]
pub struct Connection {
    conn: QStream,
}

impl Connection {


    pub async fn new(hostname: String) -> StdResult<Self, PySQLXError> {
        let conn = match kdbplus::ipc::QStream::connect(ConnectionMethod::TCP, hostname.as_str(), 5001_u16, "").await {
            Ok(r) => r,
            Err(e) => return Err(py_error(e.to_string(), DBError::ConnectError)),
        };
        Ok(Self { conn })
    }


    async fn _execute_query(&self, sql: String) -> StdResult<DataFrame, PySQLXError> {
        let result : StdResult<K, PySQLXError > = match self.conn.send_sync_message(&sql.as_str()).await {
            Ok(r) => {
                Ok(r)
            },
            Err(e) => {
                return Err(py_error(
                    String::from("Unable to execute query"),
                    DBError::QueryError,
                ))
            }
        };

        let polarsColumns = k_result_to_series(&result.unwrap());

        match DataFrame::new(polarsColumns) {
            Ok(r) => Ok(r),
            Err(e) => {
                return Err(py_error(
                    String::from("Unable to create dataframe"),
                    DBError::PolarsCreationError,
                ))
            }
        }

        //return Ok(df);
    }
}

#[pymethods]
impl Connection {
    //'a: 'b, 'b
    pub fn query<'a>(&self, py: Python<'a>, sql: String) -> PyResult<&'a PyAny> {
        //pub fn query<'a>(&self, py: Python<'a>, sql: String) -> PyResult<&'a PyAny> {

        let slf = self;
        pyo3_asyncio::tokio::future_into_py(py, async move  {
            match slf._execute_query(sql).await {
                Ok(r) => Ok(PyDataFrame(r)),
                Err(e) => Err(e.to_pyerr()),
            }
        })
    }

    pub fn is_healthy(&self) -> bool {
        return true;
        //self.conn.is_healthy()
    }
}



people: flip `name`species`steps!(`hugo`karen`holly`daisy`fern;`human`human`human`dog`dog;4000 6000 8000 2000 9876)